var _user$project$Main$isTwoCirclesCollided = F2(
	function (c1, c2) {
		var radiusSum = c1.radius + c2.radius;
		var distance = _elm_lang$core$Basics$sqrt(
			A2(
				F2(
					function (x, y) {
						return x + y;
					}),
				Math.pow(c1.x - c2.x, 2),
				Math.pow(c1.y - c2.y, 2)));
		return _elm_lang$core$Native_Utils.cmp(radiusSum, distance) > -1;
	});
var _user$project$Main$getCircleOtherColliderId = F2(
	function (list_circle, circle) {
		getCircleOtherColliderId:
		while (true) {
			var _p0 = list_circle;
			if (_p0.ctor === '[]') {
				return 0;
			} else {
				var _p2 = _p0._1;
				var _p1 = _p0._0;
				if (_elm_lang$core$Native_Utils.eq(_p1.id, circle.id)) {
					var _v1 = _p2,
						_v2 = circle;
					list_circle = _v1;
					circle = _v2;
					continue getCircleOtherColliderId;
				} else {
					if (A2(_user$project$Main$isTwoCirclesCollided, _p1, circle)) {
						return _p1.id;
					} else {
						var _v3 = _p2,
							_v4 = circle;
						list_circle = _v3;
						circle = _v4;
						continue getCircleOtherColliderId;
					}
				}
			}
		}
	});
var _user$project$Main$setSelectedCirclesToMousePosition = F2(
	function (model, mousePosition) {
		var map = function (x) {
			return x.isSelected ? _elm_lang$core$Native_Utils.update(
				x,
				{
					x: _elm_lang$core$Basics$toFloat(mousePosition.x),
					y: _elm_lang$core$Basics$toFloat(mousePosition.y)
				}) : x;
		};
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
			});
	});
var _user$project$Main$diselectCircles = function (model) {
	var map = function (x) {
		return _elm_lang$core$Native_Utils.update(
			x,
			{isSelected: false});
	};
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$selectCircle = F2(
	function (model, circle) {
		var map = function (x) {
			return _elm_lang$core$Native_Utils.eq(x.id, circle.id) ? _elm_lang$core$Native_Utils.update(
				x,
				{isSelected: true}) : x;
		};
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
			});
	});
var _user$project$Main$setOtherColliderId = F2(
	function (list_circles, circle) {
		return _elm_lang$core$Native_Utils.update(
			circle,
			{
				otherColliderId: A2(_user$project$Main$getCircleOtherColliderId, list_circles, circle)
			});
	});
var _user$project$Main$markCollidedCircles = function (model) {
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(
				_elm_lang$core$List$map,
				_user$project$Main$setOtherColliderId(model.circlesList),
				model.circlesList)
		});
};
var _user$project$Main$moveCircles = function (model) {
	var map = function (item) {
		return _elm_lang$core$Native_Utils.update(
			item,
			{
				x: item.x + (_elm_lang$core$Basics$cos(
					_elm_lang$core$Basics$degrees(item.movementDirection)) * item.movementSpeed),
				y: item.y - (_elm_lang$core$Basics$sin(
					_elm_lang$core$Basics$degrees(item.movementDirection)) * item.movementSpeed)
			});
	};
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$deflectCircle_ofCircle = F2(
	function (list_circles, circle) {
		var _p3 = list_circles;
		if (_p3.ctor === '[]') {
			return circle;
		} else {
			var _p4 = _p3._0;
			var swapMovementDirections = _elm_lang$core$Native_Utils.update(
				circle,
				{movementDirection: _p4.movementDirection});
			var otherColliderFound = _elm_lang$core$Native_Utils.eq(circle.otherColliderId, _p4.id);
			var sameCircle = _elm_lang$core$Native_Utils.eq(_p4.id, circle.id);
			var checkNextCircle = A2(_user$project$Main$deflectCircle_ofCircle, _p3._1, circle);
			return sameCircle ? checkNextCircle : (otherColliderFound ? swapMovementDirections : checkNextCircle);
		}
	});
var _user$project$Main$deflectCircle_ofBoundary = F2(
	function (boundary, circle) {
		var reflectDegree = F2(
			function (degree, direction) {
				var skip360 = function (degree) {
					return _elm_lang$core$Native_Utils.eq(degree, 360) ? 0 : degree;
				};
				var normalise = function (degree) {
					return _elm_lang$core$Basics$toFloat(
						A2(
							_elm_lang$core$Basics_ops['%'],
							_elm_lang$core$Basics$round(degree),
							360));
				};
				var normaliseAll = function (degree) {
					return skip360(
						normalise(degree));
				};
				var _p5 = direction;
				switch (_p5) {
					case 'backwards':
						return normaliseAll(
							A2(
								F2(
									function (x, y) {
										return x + y;
									}),
								180,
								degree));
					case 'horizontali':
						return normaliseAll(
							_elm_lang$core$Basics$negate(degree));
					case 'verticali':
						return normaliseAll(
							A2(
								F2(
									function (x, y) {
										return x + y;
									}),
								180,
								_elm_lang$core$Basics$negate(degree)));
					default:
						return normaliseAll(degree);
				}
			});
		var reflectCircle = function (direction) {
			return _elm_lang$core$Native_Utils.update(
				circle,
				{
					movementDirection: A2(reflectDegree, circle.movementDirection, direction)
				});
		};
		var isCircle_below_boundary = (_elm_lang$core$Native_Utils.cmp(circle.y + circle.radius, boundary.y + boundary.height) > 0) ? true : false;
		var isCircle_rightOf_boundary = (_elm_lang$core$Native_Utils.cmp(circle.x + circle.radius, boundary.x + boundary.wight) > 0) ? true : false;
		var isCircleIn_rightDown_corner = isCircle_below_boundary && isCircle_rightOf_boundary;
		var isCircle_leftOf_boundary = (_elm_lang$core$Native_Utils.cmp(circle.x - circle.radius, boundary.x) < 0) ? true : false;
		var isCircleIn_downLeft_corner = isCircle_below_boundary && isCircle_leftOf_boundary;
		var isCircle_above_boundary = (_elm_lang$core$Native_Utils.cmp(circle.y - circle.radius, boundary.y) < 0) ? true : false;
		var isCircleIn_leftUp_corner = isCircle_above_boundary && isCircle_leftOf_boundary;
		var isCircleIn_upRight_corner = isCircle_above_boundary && isCircle_rightOf_boundary;
		var isCircleInTheCorner = (isCircle_above_boundary && isCircle_leftOf_boundary) || ((isCircle_above_boundary && isCircle_rightOf_boundary) || ((isCircle_below_boundary && isCircle_rightOf_boundary) || (isCircle_below_boundary && isCircle_leftOf_boundary)));
		return isCircleInTheCorner ? reflectCircle('backwards') : ((isCircle_leftOf_boundary || isCircle_rightOf_boundary) ? reflectCircle('horizontali') : ((isCircle_above_boundary || isCircle_below_boundary) ? reflectCircle('verticali') : circle));
	});
var _user$project$Main$deflectCircles_ofCircles = function (model) {
	var map = _user$project$Main$deflectCircle_ofCircle(model.circlesList);
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$deflectCircles_ofBoundary = function (model) {
	var map = _user$project$Main$deflectCircle_ofBoundary(model.boundary);
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$print = function (log) {
	return A2(
		_elm_lang$html$Html$p,
		{ctor: '[]'},
		{
			ctor: '::',
			_0: _elm_lang$html$Html$text(log),
			_1: {ctor: '[]'}
		});
};
var _user$project$Main$boundaryToHTML = function (boundary) {
	var corectedPosition_right = boundary.y - boundary.borderThickness;
	var corectedPosition_left = boundary.x - boundary.borderThickness;
	return A2(
		_elm_lang$html$Html$div,
		{
			ctor: '::',
			_0: _elm_lang$html$Html_Attributes$style(
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'border',
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(boundary.borderThickness),
							'px solid red')
					},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 'position', _1: 'absolute'},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'height',
								_1: A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(boundary.height),
									'px')
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'width',
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(boundary.wight),
										'px')
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'left',
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(corectedPosition_left),
											'px')
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'top',
											_1: A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(corectedPosition_right),
												'px')
										},
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}
				}),
			_1: {ctor: '[]'}
		},
		{ctor: '[]'});
};
var _user$project$Main$update = F2(
	function (msg, model) {
		var _p6 = msg;
		switch (_p6.ctor) {
			case 'OnMilisecond':
				return {ctor: '_Tuple2', _0: model, _1: _elm_lang$core$Platform_Cmd$none};
			case 'OnCircleMouseDown':
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Main$selectCircle, model, _p6._0),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			case 'OnMouseUp':
				return {
					ctor: '_Tuple2',
					_0: _user$project$Main$diselectCircles(model),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			case 'OnMouseMoved':
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Main$setSelectedCirclesToMousePosition, model, _p6._0),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			default:
				return {
					ctor: '_Tuple2',
					_0: _user$project$Main$moveCircles(
						_user$project$Main$deflectCircles_ofCircles(
							_user$project$Main$deflectCircles_ofBoundary(
								_user$project$Main$markCollidedCircles(model)))),
					_1: _elm_lang$core$Platform_Cmd$none
				};
		}
	});
var _user$project$Main$frameUpdated = _elm_lang$core$Native_Platform.incomingPort('frameUpdated', _elm_lang$core$Json_Decode$string);
var _user$project$Main$Model = F2(
	function (a, b) {
		return {circlesList: a, boundary: b};
	});
var _user$project$Main$Circle = F8(
	function (a, b, c, d, e, f, g, h) {
		return {id: a, x: b, y: c, radius: d, isSelected: e, otherColliderId: f, movementDirection: g, movementSpeed: h};
	});
var _user$project$Main$justToCircle = function (justCircle) {
	var _p7 = justCircle;
	if (_p7.ctor === 'Just') {
		return _p7._0;
	} else {
		return A8(_user$project$Main$Circle, 0, 0, 0, 0, false, 0, 0, 0);
	}
};
var _user$project$Main$Boundary = F5(
	function (a, b, c, d, e) {
		return {x: a, y: b, height: c, wight: d, borderThickness: e};
	});
var _user$project$Main$initModel = {
	circlesList: {
		ctor: '::',
		_0: A8(_user$project$Main$Circle, 1, 800, 200, 50, false, 0, 135, 20),
		_1: {
			ctor: '::',
			_0: A8(_user$project$Main$Circle, 2, 1000, 250, 50, false, 0, -135, 20),
			_1: {
				ctor: '::',
				_0: A8(_user$project$Main$Circle, 3, 1400, 400, 50, false, 0, 45, 20),
				_1: {ctor: '[]'}
			}
		}
	},
	boundary: A5(_user$project$Main$Boundary, 700, 100, 700, 1000, 5)
};
var _user$project$Main$OnFrameUpdate = function (a) {
	return {ctor: 'OnFrameUpdate', _0: a};
};
var _user$project$Main$OnMouseMoved = function (a) {
	return {ctor: 'OnMouseMoved', _0: a};
};
var _user$project$Main$OnMouseUp = function (a) {
	return {ctor: 'OnMouseUp', _0: a};
};
var _user$project$Main$OnCircleMouseDown = function (a) {
	return {ctor: 'OnCircleMouseDown', _0: a};
};
var _user$project$Main$circlesToHTML = function (listOfCircles) {
	var whiteOrRed = function (circle) {
		return (_elm_lang$core$Native_Utils.cmp(circle.otherColliderId, 0) > 0) ? '#FF0000' : '#737373';
	};
	var circleToHTML = function (circle) {
		return A2(
			_elm_lang$html$Html$span,
			{
				ctor: '::',
				_0: _elm_lang$html$Html_Events$onMouseDown(
					_user$project$Main$OnCircleMouseDown(circle)),
				_1: {
					ctor: '::',
					_0: _elm_lang$html$Html_Attributes$style(
						{
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'left',
								_1: A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(circle.x - circle.radius),
									'px')
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'top',
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(circle.y - circle.radius),
										'px')
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'height',
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(circle.radius * 2),
											'px')
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'width',
											_1: A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(circle.radius * 2),
												'px')
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 'background-color',
												_1: whiteOrRed(circle)
											},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: 'position', _1: 'absolute'},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 'border-radius', _1: '50%'},
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							}
						}),
					_1: {ctor: '[]'}
				}
			},
			{ctor: '[]'});
	};
	return A2(
		_elm_lang$html$Html$div,
		{ctor: '[]'},
		A2(_elm_lang$core$List$map, circleToHTML, listOfCircles));
};
var _user$project$Main$view = function (model) {
	return A2(
		_elm_lang$html$Html$div,
		{ctor: '[]'},
		{
			ctor: '::',
			_0: _user$project$Main$print(
				_elm_lang$core$Basics$toString(model.circlesList)),
			_1: {
				ctor: '::',
				_0: _user$project$Main$boundaryToHTML(model.boundary),
				_1: {
					ctor: '::',
					_0: _user$project$Main$circlesToHTML(model.circlesList),
					_1: {ctor: '[]'}
				}
			}
		});
};
var _user$project$Main$OnMilisecond = function (a) {
	return {ctor: 'OnMilisecond', _0: a};
};
var _user$project$Main$subscriptions = function (model) {
	return _elm_lang$core$Platform_Sub$batch(
		{
			ctor: '::',
			_0: A2(_elm_lang$core$Time$every, _elm_lang$core$Time$millisecond, _user$project$Main$OnMilisecond),
			_1: {
				ctor: '::',
				_0: _elm_lang$mouse$Mouse$moves(_user$project$Main$OnMouseMoved),
				_1: {
					ctor: '::',
					_0: _elm_lang$mouse$Mouse$ups(_user$project$Main$OnMouseUp),
					_1: {
						ctor: '::',
						_0: _user$project$Main$frameUpdated(_user$project$Main$OnFrameUpdate),
						_1: {ctor: '[]'}
					}
				}
			}
		});
};
var _user$project$Main$main = _elm_lang$html$Html$program(
	{
		init: {ctor: '_Tuple2', _0: _user$project$Main$initModel, _1: _elm_lang$core$Platform_Cmd$none},
		view: _user$project$Main$view,
		update: _user$project$Main$update,
		subscriptions: _user$project$Main$subscriptions
	})();
