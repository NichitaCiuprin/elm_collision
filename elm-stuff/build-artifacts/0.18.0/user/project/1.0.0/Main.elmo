var _user$project$Main$isTwoCirclesCollided = F2(
	function (c1, c2) {
		var radiusSum = c1.radius + c2.radius;
		var distance = _elm_lang$core$Basics$sqrt(
			A2(
				F2(
					function (x, y) {
						return x + y;
					}),
				Math.pow(c1.x - c2.x, 2),
				Math.pow(c1.y - c2.y, 2)));
		return _elm_lang$core$Native_Utils.cmp(radiusSum, distance) > -1;
	});
var _user$project$Main$getCircleOtherColliderId = F2(
	function (list_circle, circle) {
		getCircleOtherColliderId:
		while (true) {
			var _p0 = list_circle;
			if (_p0.ctor === '[]') {
				return 0;
			} else {
				var _p2 = _p0._1;
				var _p1 = _p0._0;
				if (_elm_lang$core$Native_Utils.eq(_p1.id, circle.id)) {
					var _v1 = _p2,
						_v2 = circle;
					list_circle = _v1;
					circle = _v2;
					continue getCircleOtherColliderId;
				} else {
					if (A2(_user$project$Main$isTwoCirclesCollided, _p1, circle)) {
						return _p1.id;
					} else {
						var _v3 = _p2,
							_v4 = circle;
						list_circle = _v3;
						circle = _v4;
						continue getCircleOtherColliderId;
					}
				}
			}
		}
	});
var _user$project$Main$setSelectedCirclesToMousePosition = F2(
	function (model, mousePosition) {
		var map = function (x) {
			return x.isSelected ? _elm_lang$core$Native_Utils.update(
				x,
				{
					x: _elm_lang$core$Basics$toFloat(mousePosition.x),
					y: _elm_lang$core$Basics$toFloat(mousePosition.y)
				}) : x;
		};
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
			});
	});
var _user$project$Main$diselectCircles = function (model) {
	var map = function (x) {
		return _elm_lang$core$Native_Utils.update(
			x,
			{isSelected: false});
	};
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$selectCircle = F2(
	function (model, circle) {
		var map = function (x) {
			return _elm_lang$core$Native_Utils.eq(x.id, circle.id) ? _elm_lang$core$Native_Utils.update(
				x,
				{isSelected: true}) : x;
		};
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
			});
	});
var _user$project$Main$setOtherColliderId = F2(
	function (list_circles, circle) {
		return _elm_lang$core$Native_Utils.update(
			circle,
			{
				otherColliderId: A2(_user$project$Main$getCircleOtherColliderId, list_circles, circle)
			});
	});
var _user$project$Main$markCollidedCircles = function (model) {
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(
				_elm_lang$core$List$map,
				_user$project$Main$setOtherColliderId(model.circlesList),
				model.circlesList)
		});
};
var _user$project$Main$moveCircles = function (model) {
	var map = function (item) {
		return _elm_lang$core$Native_Utils.update(
			item,
			{
				x: item.x + (_elm_lang$core$Basics$cos(
					_elm_lang$core$Basics$degrees(item.movementDirection)) * item.movementSpeed),
				y: item.y - (_elm_lang$core$Basics$sin(
					_elm_lang$core$Basics$degrees(item.movementDirection)) * item.movementSpeed)
			});
	};
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$isCircle_rightOf_boundary = F2(
	function (circle, boundary) {
		return (_elm_lang$core$Native_Utils.cmp(circle.x + circle.radius, boundary.x + boundary.wight) > 0) ? true : false;
	});
var _user$project$Main$isCircle_leftOf_boundary = F2(
	function (circle, boundary) {
		return (_elm_lang$core$Native_Utils.cmp(circle.x - circle.radius, boundary.x) < 0) ? true : false;
	});
var _user$project$Main$isCircle_above_boundary = F2(
	function (circle, boundary) {
		return (_elm_lang$core$Native_Utils.cmp(circle.y - circle.radius, boundary.y) < 0) ? true : false;
	});
var _user$project$Main$isCircle_below_boundary = F2(
	function (circle, boundary) {
		return (_elm_lang$core$Native_Utils.cmp(circle.y + circle.radius, boundary.y + boundary.height) > 0) ? true : false;
	});
var _user$project$Main$isCircleIn_downLeft_corner = F2(
	function (circle, boundary) {
		return A2(_user$project$Main$isCircle_below_boundary, circle, boundary) && A2(_user$project$Main$isCircle_leftOf_boundary, circle, boundary);
	});
var _user$project$Main$isCircleIn_rightDown_corner = F2(
	function (circle, boundary) {
		return A2(_user$project$Main$isCircle_below_boundary, circle, boundary) && A2(_user$project$Main$isCircle_rightOf_boundary, circle, boundary);
	});
var _user$project$Main$isCircleIn_upRight_corner = F2(
	function (circle, boundary) {
		return A2(_user$project$Main$isCircle_above_boundary, circle, boundary) && A2(_user$project$Main$isCircle_rightOf_boundary, circle, boundary);
	});
var _user$project$Main$isCircleIn_leftUp_corner = F2(
	function (circle, boundary) {
		return A2(_user$project$Main$isCircle_above_boundary, circle, boundary) && A2(_user$project$Main$isCircle_leftOf_boundary, circle, boundary);
	});
var _user$project$Main$reflectDegree = F2(
	function (degree, isVertically) {
		var reflected = _elm_lang$core$Basics$negate(degree);
		var normalised = _elm_lang$core$Basics$toFloat(
			A2(
				_elm_lang$core$Basics_ops['%'],
				_elm_lang$core$Basics$round(reflected),
				360));
		var piToAdd = isVertically ? 180 : 0;
		var result = normalised + piToAdd;
		return _elm_lang$core$Native_Utils.eq(result, 360) ? 0 : result;
	});
var _user$project$Main$reflectCircle_horizontali = function (circle) {
	return _elm_lang$core$Native_Utils.update(
		circle,
		{
			movementDirection: A2(_user$project$Main$reflectDegree, circle.movementDirection, false)
		});
};
var _user$project$Main$reflectCircle_verticali = function (circle) {
	return _elm_lang$core$Native_Utils.update(
		circle,
		{
			movementDirection: A2(_user$project$Main$reflectDegree, circle.movementDirection, true)
		});
};
var _user$project$Main$deflectCircle_ofCircle = F2(
	function (list_circles, circle) {
		var _p3 = list_circles;
		if (_p3.ctor === '[]') {
			return circle;
		} else {
			var _p4 = _p3._0;
			var swapMovementDirections = _elm_lang$core$Native_Utils.update(
				circle,
				{movementDirection: _p4.movementDirection});
			var otherColliderFound = _elm_lang$core$Native_Utils.eq(circle.otherColliderId, _p4.id);
			var sameCircle = _elm_lang$core$Native_Utils.eq(_p4.id, circle.id);
			var checkNextCircle = A2(_user$project$Main$deflectCircle_ofCircle, _p3._1, circle);
			return sameCircle ? checkNextCircle : (otherColliderFound ? swapMovementDirections : checkNextCircle);
		}
	});
var _user$project$Main$reflectCircleBackward = function (circle) {
	return _elm_lang$core$Native_Utils.update(
		circle,
		{movementDirection: circle.movementDirection + 180});
};
var _user$project$Main$deflectCircle_ofBoundary = F2(
	function (boundary, circle) {
		return A2(_user$project$Main$isCircleIn_upRight_corner, circle, boundary) ? _user$project$Main$reflectCircleBackward(circle) : (A2(_user$project$Main$isCircleIn_rightDown_corner, circle, boundary) ? _user$project$Main$reflectCircleBackward(circle) : (A2(_user$project$Main$isCircleIn_downLeft_corner, circle, boundary) ? _user$project$Main$reflectCircleBackward(circle) : (A2(_user$project$Main$isCircleIn_leftUp_corner, circle, boundary) ? _user$project$Main$reflectCircleBackward(circle) : (A2(_user$project$Main$isCircle_leftOf_boundary, circle, boundary) ? _user$project$Main$reflectCircle_verticali(circle) : (A2(_user$project$Main$isCircle_rightOf_boundary, circle, boundary) ? _user$project$Main$reflectCircle_verticali(circle) : (A2(_user$project$Main$isCircle_above_boundary, circle, boundary) ? _user$project$Main$reflectCircle_horizontali(circle) : (A2(_user$project$Main$isCircle_below_boundary, circle, boundary) ? _user$project$Main$reflectCircle_horizontali(circle) : circle)))))));
	});
var _user$project$Main$deflectCircles_ofCircles = function (model) {
	var map = _user$project$Main$deflectCircle_ofCircle(model.circlesList);
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$deflectCircles_ofBoundary = function (model) {
	var map = _user$project$Main$deflectCircle_ofBoundary(model.boundary);
	return _elm_lang$core$Native_Utils.update(
		model,
		{
			circlesList: A2(_elm_lang$core$List$map, map, model.circlesList)
		});
};
var _user$project$Main$print = function (log) {
	return A2(
		_elm_lang$html$Html$p,
		{ctor: '[]'},
		{
			ctor: '::',
			_0: _elm_lang$html$Html$text(log),
			_1: {ctor: '[]'}
		});
};
var _user$project$Main$boundaryToHTML = function (boundary) {
	var borderThickness = 5;
	return A2(
		_elm_lang$html$Html$div,
		{
			ctor: '::',
			_0: _elm_lang$html$Html_Attributes$style(
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'border',
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(borderThickness),
							'px solid red')
					},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 'position', _1: 'absolute'},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'height',
								_1: A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(boundary.height),
									'px')
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'width',
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(boundary.wight),
										'px')
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'left',
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(boundary.x - borderThickness),
											'px')
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'top',
											_1: A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(boundary.y - borderThickness),
												'px')
										},
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}
				}),
			_1: {ctor: '[]'}
		},
		{ctor: '[]'});
};
var _user$project$Main$update = F2(
	function (msg, model) {
		var _p5 = msg;
		switch (_p5.ctor) {
			case 'OnMilisecond':
				return {ctor: '_Tuple2', _0: model, _1: _elm_lang$core$Platform_Cmd$none};
			case 'OnCircleMouseDown':
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Main$selectCircle, model, _p5._0),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			case 'OnMouseUp':
				return {
					ctor: '_Tuple2',
					_0: _user$project$Main$diselectCircles(model),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			case 'OnMouseMoved':
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Main$setSelectedCirclesToMousePosition, model, _p5._0),
					_1: _elm_lang$core$Platform_Cmd$none
				};
			default:
				return {
					ctor: '_Tuple2',
					_0: _user$project$Main$moveCircles(
						_user$project$Main$deflectCircles_ofCircles(
							_user$project$Main$deflectCircles_ofBoundary(
								_user$project$Main$markCollidedCircles(model)))),
					_1: _elm_lang$core$Platform_Cmd$none
				};
		}
	});
var _user$project$Main$frameUpdated = _elm_lang$core$Native_Platform.incomingPort('frameUpdated', _elm_lang$core$Json_Decode$string);
var _user$project$Main$Model = F2(
	function (a, b) {
		return {circlesList: a, boundary: b};
	});
var _user$project$Main$Circle = F8(
	function (a, b, c, d, e, f, g, h) {
		return {id: a, x: b, y: c, radius: d, isSelected: e, otherColliderId: f, movementDirection: g, movementSpeed: h};
	});
var _user$project$Main$justToCircle = function (justCircle) {
	var _p6 = justCircle;
	if (_p6.ctor === 'Just') {
		return _p6._0;
	} else {
		return A8(_user$project$Main$Circle, 0, 0, 0, 0, false, 0, 0, 0);
	}
};
var _user$project$Main$Boundary = F4(
	function (a, b, c, d) {
		return {x: a, y: b, height: c, wight: d};
	});
var _user$project$Main$initModel = {
	circlesList: {
		ctor: '::',
		_0: A8(_user$project$Main$Circle, 1, 800, 200, 50, false, 0, 135, 20),
		_1: {
			ctor: '::',
			_0: A8(_user$project$Main$Circle, 2, 1000, 250, 50, false, 0, -135, 20),
			_1: {
				ctor: '::',
				_0: A8(_user$project$Main$Circle, 3, 1400, 400, 50, false, 0, 45, 20),
				_1: {ctor: '[]'}
			}
		}
	},
	boundary: A4(_user$project$Main$Boundary, 700, 100, 700, 1000)
};
var _user$project$Main$OnFrameUpdate = function (a) {
	return {ctor: 'OnFrameUpdate', _0: a};
};
var _user$project$Main$OnMouseMoved = function (a) {
	return {ctor: 'OnMouseMoved', _0: a};
};
var _user$project$Main$OnMouseUp = function (a) {
	return {ctor: 'OnMouseUp', _0: a};
};
var _user$project$Main$OnCircleMouseDown = function (a) {
	return {ctor: 'OnCircleMouseDown', _0: a};
};
var _user$project$Main$circlesToHTML = function (listOfCircles) {
	var whiteOrRed = function (circle) {
		return (_elm_lang$core$Native_Utils.cmp(circle.otherColliderId, 0) > 0) ? '#FF0000' : '#737373';
	};
	var circleToHTML = function (circle) {
		return A2(
			_elm_lang$html$Html$span,
			{
				ctor: '::',
				_0: _elm_lang$html$Html_Events$onMouseDown(
					_user$project$Main$OnCircleMouseDown(circle)),
				_1: {
					ctor: '::',
					_0: _elm_lang$html$Html_Attributes$style(
						{
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'left',
								_1: A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(circle.x - circle.radius),
									'px')
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'top',
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(circle.y - circle.radius),
										'px')
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'height',
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(circle.radius * 2),
											'px')
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'width',
											_1: A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(circle.radius * 2),
												'px')
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 'background-color',
												_1: whiteOrRed(circle)
											},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: 'position', _1: 'absolute'},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 'border-radius', _1: '50%'},
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							}
						}),
					_1: {ctor: '[]'}
				}
			},
			{ctor: '[]'});
	};
	return A2(
		_elm_lang$html$Html$div,
		{ctor: '[]'},
		A2(_elm_lang$core$List$map, circleToHTML, listOfCircles));
};
var _user$project$Main$view = function (model) {
	var circle = _user$project$Main$justToCircle(
		_elm_lang$core$List$head(model.circlesList));
	return A2(
		_elm_lang$html$Html$div,
		{ctor: '[]'},
		{
			ctor: '::',
			_0: _user$project$Main$print(
				_elm_lang$core$Basics$toString(model.circlesList)),
			_1: {
				ctor: '::',
				_0: _user$project$Main$boundaryToHTML(model.boundary),
				_1: {
					ctor: '::',
					_0: _user$project$Main$circlesToHTML(model.circlesList),
					_1: {ctor: '[]'}
				}
			}
		});
};
var _user$project$Main$OnMilisecond = function (a) {
	return {ctor: 'OnMilisecond', _0: a};
};
var _user$project$Main$subscriptions = function (model) {
	return _elm_lang$core$Platform_Sub$batch(
		{
			ctor: '::',
			_0: A2(_elm_lang$core$Time$every, _elm_lang$core$Time$millisecond, _user$project$Main$OnMilisecond),
			_1: {
				ctor: '::',
				_0: _elm_lang$mouse$Mouse$moves(_user$project$Main$OnMouseMoved),
				_1: {
					ctor: '::',
					_0: _elm_lang$mouse$Mouse$ups(_user$project$Main$OnMouseUp),
					_1: {
						ctor: '::',
						_0: _user$project$Main$frameUpdated(_user$project$Main$OnFrameUpdate),
						_1: {ctor: '[]'}
					}
				}
			}
		});
};
var _user$project$Main$main = _elm_lang$html$Html$program(
	{
		init: {ctor: '_Tuple2', _0: _user$project$Main$initModel, _1: _elm_lang$core$Platform_Cmd$none},
		view: _user$project$Main$view,
		update: _user$project$Main$update,
		subscriptions: _user$project$Main$subscriptions
	})();
